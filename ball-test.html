<!doctype html>
<html>
  <head>

  <style>
		path {
		  stroke: #fff;
		}

		path:first-child {
		  fill: yellow !important;
		}

		circle {
		  fill: #000;
		  pointer-events: none;
		}

	</style>

  <script src="js/jquery-1.11.3.min.js"></script>
  <script src="js/paper-full.min.js"></script>
  <script src="js/d3.min.js"></script>

  <!--<script type="text/paperscript" canvas="canvas">-->
  <script type="text/javascript">

	$(document).ready(function () {

		// TODO: Once the document has loaded get the canvas size 
		// var width = $("#canvas").width();
		// var height = $("#canvas").height();

		var width = 950, height = 500;

		// var nodes = d3.range(50).map(function () { return {radius: Math.random() * 12 + 4}; }),
		//     root = nodes[0],
		//     color = d3.scale.category10();

		// root.radius = 0;
		// root.fixed = true;

		// var force = d3.layout.force()
		//     .gravity(0.05)
		//     .charge(function(d, i) { return i ? 0 : -2000; })
		//     .nodes(nodes)
		//     .size([width, height]);

		// force.start();

		var svg = d3.select("body").append("svg")
		    .attr("width", width)
		    .attr("height", height)
		    .attr("id", "svg-canvas");

		// svg.selectAll("circle")
		//     .data(nodes.slice(1))
		//   	.enter().append("circle")
		//     .attr("r", function(d) { return d.radius; })
		//     .style("fill", "purple")
		//     .style("opacity", 0.7)
		//     .style("stroke", "black");

		// force.on("tick", function(e) {
		//   var q = d3.geom.quadtree(nodes),
		//       i = 0,
		//       n = nodes.length;

		//   while (++i < n) q.visit(collide(nodes[i]));

		//   svg.selectAll("circle")
		//       .attr("cx", function(d) { return d.x; })
		//       .attr("cy", function(d) { return d.y; });
		// });

		// function collide(node) {
		//   var r = node.radius + 16,
		//       nx1 = node.x - r,
		//       nx2 = node.x + r,
		//       ny1 = node.y - r,
		//       ny2 = node.y + r;
		//   return function(quad, x1, y1, x2, y2) {
		//     if (quad.point && (quad.point !== node)) {
		//       var x = node.x - quad.point.x,
		//           y = node.y - quad.point.y,
		//           l = Math.sqrt(x * x + y * y),
		//           r = node.radius + quad.point.radius;
		//       if (l < r) {
		//         l = (l - r) / l * .5;
		//         node.x -= x *= l;
		//         node.y -= y *= l;
		//         quad.point.x += x;
		//         quad.point.y += y;
		//       }
		//     }
		//     return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
		//   };
		// }


		/* Create the haplet */

		// Draw the tablet  
		var tablet = function () {
			var tab = {};

			// Variables controlling size
			tab.length = 600;
			tab.width = tab.length / 1.4;
			tab.padding = 35;
			tab.top = {x: (width / 2) - (tab.length / 2), y: 30};

			// The black outline of the tablet 
			tab.casing = svg.append("rect")
					.attr("x", tab.top.x)
					.attr("y", tab.top.y)
					.attr("width", tab.length)
					.attr("height", tab.width)
					.attr("rx", 23).attr("ry", 23)
					.style("fill", "white")
					.style("stroke", "grey")
					.style("stroke-width", 2);

			// The screen of the tablet 
			tab.screen = svg.append("rect")
						.attr("x", tab.top.x + tab.padding)
						.attr("y", tab.top.y + tab.padding)
						.attr("width", tab.length - (tab.padding * 2))
						.attr("height", tab.width - (tab.padding * 2))
						.style("fill", "white")
						.style("stroke", "grey")
						.style("stroke-width", 2);

			// On button 
			var button_x = tab.top.x + 15;
			var button_y = tab.width / 2 + 30;
			tab.button = svg.append("circle")
						.attr("cx", button_x).attr("cy", button_y)
						.attr("r", 10)
						.style("fill", "white")
						.style("stroke", "grey")
						.style("stroke-width", 2);

			return tab;
		}();

		// Draw the haplet 
		var haplet = function () {
			var hap = {};

			// Where the device will be positioned 
			var start_pos = {x: tablet.top.x / 2, y: tablet.top.y};

			// Define arm size and joint positions
			var arm_size = 185;
			var joint1 = {x: start_pos.x - 10, y: start_pos.y + arm_size};
			var joint2 = {x: start_pos.x + 10, y: start_pos.y + arm_size};
			
			var stylus_position = {x: start_pos.x, arm_}

		}();

		// Draw the base motors in the middle of the canvas 
		// var motor_radius = 20, mid = width / 2, overlap = 10, start_height = 60;
		// var motor_center1 = new Point(mid - motor_radius + overlap, start_height);
		// var motor_center2 = new Point(mid + motor_radius - overlap, start_height);
		// var motor1 = new Path.Circle(motor_center1, motor_radius);
		// var motor2 = new Path.Circle(motor_center2, motor_radius);

		// // Define arm size and joint positions 
		// var arm_size = 185;
		// var joint1 = new Point(motor_center1.x, motor_center1.y + arm_size);
		// var joint2 = new Point(motor_center2.x, motor_center2.y + arm_size);

		// // Define the stylus position 
		// var stylus_pos = new Point(mid, arm_size * 2);

		// // Draw the first two arms (top of joints)
		// var top = new Point(mid, start_height);
		// var arm1 = new Path(top, joint1);
		// var arm2 = new Path(top, joint2);

		// // Draw the second two arms (bottom of joints)
		// var bottom = new Point(mid, joint1.y + arm_size);
		// var arm3 = new Path(joint1, new Point(mid, bottom));
		// var arm4 = new Path(joint2, new Point(mid, bottom));

		// // Draw the stylus 
		// var stylus_radius = 20;
		// var stylus = new Path.Circle(new Point(mid, joint1.y + arm_size), stylus_radius);

		// /* Styling functions */ 

		// // Style the motors 
		// var motor_style = function (motor) {
		// 	motor.fillColor = 'black';
		// 	motor.opacity = 0.8;
		// };

		// // Style the arms 
		// var arm_style = function (arm, color) {
		// 	arm.strokeColor = color;
		// 	arm.strokeWidth = 20;
		// 	arm.strokeCap = 'round';
		// 	arm.opacity = 0.7;
		// };

		// // Apply motor styles 
		// // motor_style(motor1);
		// // motor_style(motor2);

		// // Apply arm styles
		// arm_style(arm1, '#87CEFA');
		// arm_style(arm2, '#87CEFA');
		// arm_style(arm3, '#191970');
		// arm_style(arm4, '#191970');

		// // Style the stylus, stylishly  
		// stylus.fillColor = 'white';
		// stylus.strokeColor = 'grey'
		// stylus.strokeWidth = 3;
		// stylus.opacity = 0.85;

		// // The arms fade colors 
		// var color_changer = setInterval(function () {
		// }, 500);

		// /* Movement functionality */
		// var moving = false;

		// // Compute distance between joint and center 
		// var joint_dist = function (x) {
		// 	return Math.sqrt(Math.pow(arm_size, 2) - Math.pow(x / 2.0, 2)) || 0;
		// };

		// // True if coordinates are in the stylus
		// var clicked = function (x, y) {
		// 	var r = Math.pow(stylus.position.x - x, 2) + Math.pow(stylus.position.y - y, 2);
		// 	return r <= Math.pow(stylus_radius, 2);
  //       };

		// // Mouse click event listener 
		// $("#canvas").mousedown(function (event) {
		// 	// If we've clicked on the stylus, start moving
		// 	if (clicked(event.pageX, event.pageY)) {
		// 		moving = true;

		// 		// Fix the arm color 
		// 		clearInterval(color_changer);
		// 	}
		// });

		// $("#canvas").mousemove(function (event) {
		// 	// Only move everything if we've already clicked on the stylus
		// 	// and within the movable frame  
		// 	if (moving && event.pageY > joint1.y && event.pageY < bottom.y) {

		// 		// Move the stylus
		// 		stylus.position.y = event.pageY;

		// 		// Get the top to bottom length
		// 		var l = stylus.position.y - top.y;

		// 		// Calculate the length-wise distance the joint must move
		// 		var d = joint_dist(l);

		// 		// Move the joint/arms
		// 		arm1.segments[1].point.x = mid - d;
		// 		arm2.segments[1].point.x = mid + d;
		// 		arm3.segments[0].point.x = mid - d;
		// 		arm4.segments[0].point.x = mid + d;
		// 		arm3.segments[1].point.y = event.pageY;
		// 		arm4.segments[1].point.y = event.pageY;

		// 		// Move the balls 
		// 	  	root.px = event.pageX;
		// 	  	root.py = event.pageY;
		// 	  	force.resume();

		// 	}
		// });

		// // Mouse up event listener 
		// $("#canvas").mouseup(function (event) {
		// 	moving = false;

		// 	// Gracefully return to starting position 
		// });

	});

  </script>

</head>

<body>
</body>

</html>
